{"name":"apat: Android performance analysis tools","tagline":"","body":"# apat: android-analysis-tools\r\nTools to analyze performance of Android applications.\r\n\r\n[![Build Status](https://travis-ci.org/madvay/android-analysis-tools.svg?branch=master)](https://travis-ci.org/madvay/android-analysis-tools)\r\n\r\n## Running from a distribution\r\nRun the `bin/apat` script per the Usage section.\r\n\r\nSee [walkthough.md](walkthrough.md) for a step-by-step walkthrough\r\nof using `apat` to solve a real-life memory problem.\r\n\r\n## Usage\r\n<!-- The content between the ```hashes``` will also be displayed\r\n     as the usage notice by the Java binary. -->\r\n```\r\nandroid-analysis-tools - https://madvay.com/source/apat\r\nTools to analyze performance of Android applications.\r\n\r\nUSAGE\r\napat <command> <options>\r\n\r\nAVAILABLE COMMANDS\r\n help               - Prints this usage message.\r\n version            - Prints version and copyright notice.\r\n license            - Prints the full LICENSE file.\r\n allocs             - Allocation analysis on DDMS .alloc file\r\n    list <file>         - Query lists of allocations\r\n    top <file>          - Histograms for aggregate allocation\r\n\r\nCONFIGURATION\r\n\r\n Data is processed in this order, for the given subcommands:\r\n 1. Call site transformation [allocs list, allocs top]\r\n 2. Split by trace [allocs list, allocs top]\r\n 3. Row filtering [allocs list, allocs top]\r\n 4. Row aggregation [allocs top]\r\n 5. Sorting [allocs list, allocs top]\r\n 6. Formatting [allocs list, allocs top]\r\n\r\n See EXAMPLES below for common queries and use-cases.\r\n\r\n Because queries can get long and be difficult to escape in your\r\n shell, you can instead store (a subset of) your flags in a file:\r\n\r\n   --config=file.cfg\r\n\r\n Config files provide one argument per line.  Blank lines or lines\r\n beginning in hash symbols are ignored for whitespace and comments.\r\n Config files can reference other config files using --config.\r\n\r\nCALL SITE TRANSFORMS:\r\n --traceTransform=<transformSpec>\r\n\r\n Adjusts every stack trace per the spec.\r\n Given a stack trace [A, B, C], A is the ultimate call site,\r\n B is the penultimate call site and so on.  A is considered\r\n 'above' B for the purposes of transforms.  A is also\r\n considered 'top' and C 'bottom'.\r\n\r\n The transformSpec is one of:\r\n\r\n pruneRecursion        - Removes A from [A, B] if A has the same class\r\n                         and method as B.  Note that overloaded variants\r\n                         will be treated as \"recursion\" by this definition.\r\n\r\n prune:<elementSpec>   - Removes stack trace elements (STE)\r\n                         which match the elementSpec.\r\n\r\n keep:<elementSpec>    - Keeps only STEs which match the\r\n                         elementSpec.\r\n\r\n pruneAbove:<elementSpec>\r\n                       - Remove all STE above the first STE\r\n                         which matches the elementSpec. If no STE\r\n                         matches the elementSpec, all STEs are pruned.\r\n\r\n pruneBelow:<elementSpec>\r\n                       - Remove all STE below the last STE\r\n                         which matches the elementSpec. If no STE\r\n                         matches the elementSpec, all STEs are pruned.\r\n\r\n keepAbove:<elementSpec>\r\n                       - Keeps only STE above the first STE\r\n                         which matches the elementSpec. If no STE\r\n                         matches the elementSpec, all STEs are kept.\r\n\r\n keepBelow:<elementSpec>\r\n                       - Keeps only STE above the last STE\r\n                         which matches the elementSpec. If no STE\r\n                         matches the elementSpec, all STEs are kept.\r\n\r\n Multiple transforms may be specified with multiple flags.\r\n Note all such transformations are applied in order, and\r\n before any filtering of rows based on the stack trace (see below).\r\n Note that a row will not be filtered out automatically because no STEs\r\n are left.\r\n\r\n The elementSpec is a semicolon separated sequence of expressions:\r\n\r\n [contains:]<text>     - STE textual form contains the text\r\n                         (default when no other operator is specified)\r\n\r\n underPackage:<package>\r\n                       - STE class under package or any subpackage.\r\n inPackage:<package>   - STE class in the package (only).\r\n\r\n classEq:<class>       - STE class equal to that class.\r\n classRe:<classRegex>  - STE class that matches the given pattern.\r\n class:<text>          - STE class contains text.\r\n\r\n methodEq:<method>     - STE method equal to that method.\r\n methodRe:<methodRegex>\r\n                       - STE method that matches the given pattern.\r\n method:<text>         - STE method contains text.\r\n\r\n siteEq:<classAndMethod>\r\n                       - STE \"class.method\" equal to the site.\r\n siteRe:<classAndMethodRegex>\r\n                       - STE \"class.method\" that matches the given pattern.\r\n site:<text>           - STE \"class.method\" contains text.\r\n\r\n When multiple expressions are present, the elementSpec is treated as a\r\n conjunction.\r\n\r\n\r\nROW MATCHING FILTERS:\r\n --id=<filter>         - Allocation id (numeric)\r\n\r\n --allocated=<filter>  - Allocated class name\r\n\r\n --size=<filter>       - Allocation size in bytes (numeric)\r\n\r\n --thread=<filter>     - Allocating thread id (numeric)\r\n\r\n --stackTrace=<filter> - Joined allocation site stack trace\r\n\r\n --allocator=<filter>  - STE at the top of the stack trace\r\n\r\n --allocatorClass=<filter>\r\n                       - Class of STE at the top of the stack trace\r\n\r\n --allocatorMethod=<filter>\r\n                       - \"class.method\" of STE at the top of the\r\n                         stack trace\r\n\r\n Matches attributes via a filter spec,\r\n [<comparison>:]<rhs> where comparison is one of:\r\n     eq  - lhs == rhs, default comparison when none specified\r\n     ne  - lhs != rhs\r\n     lt  - lhs <  rhs\r\n     le  - lhs <= rhs\r\n     gt  - lhs >  rhs\r\n     ge  - lhs >= rhs\r\n     re  - lhs matches the regular expression rhs\r\n     nre - lhs does not march regular expression rhs\r\n     ss  - substring, i.e. lhs.contains(rhs)\r\n     nss - not substring, i.e. !lhs.contains(rhs)\r\n Repeating a flag creates a conjunction filter.\r\n\r\n Ex: --thread=ne:14 --size=gt:16 --size=le:128\r\n matches allocations not on thread 14, with a size greater\r\n than 16 bytes and less than or equal to 128 bytes.\r\n\r\n Ex: --thread=12\r\n matches allocations on thread 12.\r\n\r\n\r\nAGGREGATION (only for [allocs top]):\r\n\r\n --weight=<column>     - Choose between id (count), size (sum), or another\r\n                         column, which will be counted by its unique values.\r\n                         Default: size (sum)\r\n\r\n --groupBy=<column>    - Specifies the column to group by, defaults to\r\n                         allocatorMethod.\r\n\r\n\r\nLISTING (only for [allocs list]):\r\n\r\n --samples=<N>         - Return only a random sample of N rows.\r\n                         Default: -1 (all)\r\n\r\n\r\nOTHER FLAGS:\r\n\r\n --splitByTrace=true   - Splits a row with multiple trace elements [A,B,C]\r\n                         into three rows, each one a single trace element\r\n                         [A], [B], and [C].  This is particularly useful\r\n                         to hold callers responsible for all their callees'\r\n                         allocations in [allocs top] mode.\r\n                         Default: false\r\n\r\n --sort=<spec>         - Sorts the rows, where spec is a comma-separated\r\n                         list of columns.  A column prefixed with a hyphen\r\n                         is sorted in descending order, otherwise in\r\n                         ascending order.\r\n                         Ex: --sort=thread,-size (asc. by thread, then\r\n                         desc. by size)\r\n                         For [allocs top], defaults to {-weight,group}.\r\n                         For [allocs list], no default.  You can use any\r\n                         of the columns named above in 'row matching\r\n                         filters'.\r\n\r\n --format=csv|pretty   - Selects the output format.\r\n                         Default: pretty\r\n\r\n\r\nPREREQUISITES:\r\nYou need an .alloc file generated by DDMS in Android Studio or IntelliJ IDEA:\r\nhttps://developer.android.com/tools/debugging/debugging-studio.html#allocTracker\r\n\r\n\r\nEXAMPLES:\r\n\r\napat allocs list file.alloc --sort=-size --thread=1 --format=csv \\\r\n    --allocated=java.lang.String\r\n\r\n  Dumps a CSV of all String allocations on thread 1 in descending size order.\r\n\r\n\r\napat allocs list file.alloc --sort=id --size=gt:1024\r\n\r\n  Pretty-prints in order of allocation everything above 1KB.\r\n\r\n\r\napat allocs list file.alloc --sort=id --format=pretty \\\r\n    --traceTransform=prune:underPackage:java \\\r\n    --traceTransform=prune:underPackage:javax\r\n\r\n  Pretty-prints in order of allocation, with all java.** and javax.**\r\n  methods elided from the stack traces.\r\n\r\n\r\napat allocs list file.alloc --sort=thread,id --format=pretty \\\r\n    --traceTransform=pruneAbove:underPackage:com.example \\\r\n    --stackTrace=re:.\\*com\\\\.example\\\\..\\*\r\n\r\n  Pretty-prints in order of allocation but separated by thread,\r\n  showing the ultimate allocation site as the last responsible method\r\n  under the com.example.** package, and excluding all allocations that\r\n  did not involve the com.example package.\r\n\r\n\r\napat allocs top file.alloc --format=pretty \\\r\n    --traceTransform=pruneAbove:underPackage:com.example \\\r\n    --groupBy=allocatorMethod --thread=17 \\\r\n    --splitByTrace=true\r\n\r\n  Displays the top methods in com.example both directly and indirectly\r\n  allocating memory on thread 17.  Memory not indirectly chargeable to a\r\n  com.example method will show up under {none}.  --splitByTrace=true causes\r\n  every method in the chain to have callees' memory charged to the caller\r\n  as well.\r\n\r\n\r\napat allocs top file.alloc --format=pretty \\\r\n    --traceTransform=prune:underPackage:java \\\r\n    --traceTransform=prune:underPackage:javax \\\r\n    --groupBy=allocatorClass\r\n\r\n  Displays the top classes outside of java/javax most closely responsible\r\n  for directly allocating memory.\r\n\r\n\r\napat allocs list file.alloc --sort=thread,id --format=pretty \\\r\n    --traceTransform=pruneAbove:underPackage:com.example,methodEq:\\<init\\> \\\r\n    --traceTransform=prune:underPackage:java \\\r\n    --traceTransform=prune:underPackage:javax \\\r\n    --stackTrace=re:.\\*com\\\\.example\\\\..\\* \\\r\n    --allocated=ne:java.lang.String\r\n\r\n  Pretty-prints in order of allocation but separated by thread,\r\n  showing the ultimate allocation site as the last responsible constructor\r\n  under the com.example.** package, and excluding all allocations that\r\n  did not involve the com.example package, and ignoring all calls\r\n  within the java.** and javax.** packages, and excluding allocations of\r\n  Strings.\r\n\r\n  This example can also be run as:\r\n\r\napat allocs list file.alloc --config=file.cfg\r\n\r\n  where file.cfg contains:\r\n\r\n--sort=thread,id\r\n--format=pretty\r\n\r\n# Hold final constructor under com.example.** responsible.\r\n--traceTransform=pruneAbove:underPackage:com.example,methodEq:<init>\r\n\r\n--traceTransform=prune:underPackage:java\r\n--traceTransform=prune:underPackage:javax\r\n--stackTrace=re:.*com\\.example\\..*\r\n--allocated=ne:java.lang.String\r\n\r\n  Note that characters no longer need to be shell-escaped, and comments\r\n  are allowed.\r\n```\r\n\r\n## Building from source\r\n1.  Clone the repository:\r\n`git clone https://github.com/madvay/android-analysis-tools.git`\r\n2.  Build and run from the local repository: `./apat [args]`\r\n\r\n## License\r\nSee the [LICENSE](LICENSE) and the [NOTICE](NOTICE) (per Section 4 d of the\r\nLicense) files.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}